//! Grpc Simple resource Traits

pub use crate::common::ArrErr;

use std::marker::PhantomData;
use tokio_postgres::Row;
use tonic::{Code, Request, Response, Status};

use super::server::*;
use super::GrpcDataObjectType;
use crate::postgres::simple_resource::{PsqlObjectType, PsqlType};
use crate::postgres::PsqlSearch;
use crate::resources::base::simple_resource::{GenericResourceResult, ObjectType, SimpleResource};

/// Generic gRPC object traits to provide wrappers for common `Resource` functions
#[tonic::async_trait]
pub trait GrpcSimpleService<T, U>
where
    T: ObjectType<U> + PsqlType + PsqlSearch + SimpleResource<U> + From<Id> + Clone + Sync + Send,
    U: GrpcDataObjectType + TryFrom<Row>,
    Status: From<<U as TryFrom<Row>>::Error>,
{
    /// Returns a [`tonic`] gRCP [`Response`] containing an object of provided type `V`.
    /// `V` will contain the record data found for the provided [`Id`].
    ///
    /// # Errors
    ///
    /// Returns [`Status`] with [`Code::NotFound`] if no record is returned from the database.  
    /// Returns [`Status`] with [`Code::Internal`] if the provided Id can not be converted to a [`uuid::Uuid`].  
    /// Returns [`Status`] with [`Code::Internal`] if the resulting [`Row`] data could not be converted into `U`.  
    ///
    async fn generic_get_by_id<V>(&self, request: Request<Id>) -> Result<Response<V>, Status>
    where
        V: From<T>,
    {
        let id: Id = request.into_inner();
        let mut resource: T = id.clone().into();
        let obj: Result<Row, ArrErr> = T::get_by_id(&resource.try_get_uuid()?).await;
        if let Ok(obj) = obj {
            resource.set_data(obj.try_into()?);
            Ok(Response::new(resource.into()))
        } else {
            let error = format!("No resource found for specified uuid: {}", id.id);
            grpc_error!("{}", error);
            Err(Status::new(Code::NotFound, error))
        }
    }

    /// Returns a [`tonic`] gRCP [`Response`] containing an object of provided type `V`.
    /// `V`(TryFrom\<Vec\<Row\>\>) will contain all records found in the database using the the provided [`AdvancedSearchFilter`].
    ///
    /// This method supports paged results.
    ///
    /// # Errors
    ///
    /// Returns [`Status`] with [`Code::Internal`] if any error is returned from the db search result.  
    /// Returns [`Status`] with [`Code::Internal`] if the resulting [`Vec<Row>`] data could not be converted into `V`.  
    ///
    async fn generic_search<V>(
        &self,
        request: Request<AdvancedSearchFilter>,
    ) -> Result<Response<V>, Status>
    where
        V: TryFrom<Vec<Row>>,
        Status: From<<V as TryFrom<Vec<Row>>>::Error>,
    {
        let filter: AdvancedSearchFilter = request.into_inner();
        match T::advanced_search(filter).await {
            Ok(rows) => Ok(Response::new(rows.try_into()?)),
            Err(e) => Err(Status::new(Code::Internal, e.to_string())),
        }
    }

    /// Returns a [`tonic`] gRCP [`Response`] containing an object of provided type `V`.
    /// `V`(From<GenericResourceResult<T, U>>) will contain the inserted record after saving the provided data `U`.
    ///
    /// The given data will be validated before insert.  
    /// A new UUID will be generated by the database and returned as `id` as part of the returned `U` object.  
    /// Any errors found during validation will be added to the [`ValidationResult`](crate::resources::ValidationResult).  
    ///
    /// # Errors
    ///
    /// Returns [`Status`] with [`Code::Internal`] if the [`Request`] doesn't contain any data.  
    /// Returns [`Status`] with [`Code::Internal`] if any error is returned from a db call.
    ///
    async fn generic_insert<V>(&self, request: Request<U>) -> Result<Response<V>, Status>
    where
        T: From<U> + SimpleResource<U>,
        U: 'async_trait,
        V: From<GenericResourceResult<T, U>>,
    {
        let data = request.into_inner();
        let mut resource: T = data.into();
        grpc_debug!("Inserting with data {:?}", resource.try_get_data()?);
        let (id, validation_result) = T::create(&resource.try_get_data()?).await?;
        if let Some(id) = id {
            resource.set_id(id.to_string());
            let obj: T = resource;
            let result = GenericResourceResult::<T, U> {
                phantom: PhantomData,
                validation_result,
                resource: Some(obj),
            };
            Ok(Response::new(result.into()))
        } else {
            let error = "Error calling insert function";
            grpc_error!("{}", error);
            grpc_debug!("{:?}", resource.try_get_data()?);
            grpc_debug!("{:?}", validation_result);
            let result = GenericResourceResult::<T, U> {
                phantom: PhantomData,
                validation_result,
                resource: None,
            };
            Ok(Response::new(result.into()))
        }
    }

    /// Returns a [`tonic`] gRCP [`Response`] containing an object of provided type `V`.
    /// `V`(GenericResourceResult<T, U>) will contain the updated record after saving the provided data `U`.
    ///
    /// The given data will be validated before insert.
    /// Any errors found during validation will be added to the [`ValidationResult`](crate::resources::ValidationResult).
    /// A field [`prost_types::FieldMask`] can be provided to restrict updates to specific fields.
    ///
    /// # Errors
    ///
    /// Returns [`Status`] with [`Code::Cancelled`] if the [`Request`] doesn't contain any data.  
    /// Returns [`Status`] with [`Code::Internal`] if any error is returned from a db call.  
    /// Returns [`Status`] with [`Code::Internal`] if the provided Id can not be converted to a [`uuid::Uuid`].  
    /// Returns [`Status`] with [`Code::Internal`] if the resulting [`Row`] data could not be converted into `U`.  
    ///
    async fn generic_update<V, W>(&self, request: Request<W>) -> Result<Response<V>, Status>
    where
        T: From<W> + PsqlObjectType<U> + SimpleResource<U>,
        V: From<GenericResourceResult<T, U>>,
        W: Send,
    {
        let req: T = request.into_inner().into();
        let id: Id = Id {
            id: req.try_get_id()?,
        };
        let mut resource: T = id.into();

        let data = match req.get_data() {
            Some(data) => data,
            None => {
                let err = format!("No data provided for update with id: {}", req.try_get_id()?);
                grpc_error!("{}", err);
                return Err(Status::cancelled(err));
            }
        };

        let (data, validation_result) = resource.update(&data).await?;
        if let Some(data) = data {
            resource.set_data(data.try_into()?);
            let result = GenericResourceResult {
                phantom: PhantomData,
                validation_result,
                resource: Some(resource),
            };
            Ok(Response::new(result.into()))
        } else {
            let error = "Error calling update function";
            grpc_error!("{}", error);
            grpc_debug!("{:?}", data);
            grpc_debug!("{:?}", validation_result);
            let result = GenericResourceResult {
                phantom: PhantomData,
                validation_result,
                resource: None,
            };
            Ok(Response::new(result.into()))
        }
    }

    /// Takes an [`Id`] to set the matching database record as deleted in the database.
    ///
    /// # Errors
    ///
    /// Returns [`Status`] with [`Code::NotFound`] if no record is returned from the database.  
    /// Returns [`Status`] with [`Code::Internal`] if any error is returned from a db call.  
    async fn generic_delete(&self, request: Request<Id>) -> Result<Response<()>, Status>
    where
        T: PsqlObjectType<U>,
    {
        let id: Id = request.into_inner();
        let resource: T = id.into();
        match resource.delete().await {
            Ok(_) => Ok(Response::new(())),
            Err(e) => Err(Status::new(Code::Internal, e.to_string())),
        }
    }
}
