//! Vertiports

mod grpc_server {
    #![allow(unused_qualifications, missing_docs)]
    tonic::include_proto!("grpc.vertiport");
}

use super::VertiportPsql;
use crate::get_psql_pool;
use crate::grpc::*;
use crate::grpc_error;
use crate::memdb::MEMDB_LOG_TARGET;
use crate::memdb::VERTIPORTS;
use crate::memdb_info;
use uuid::Uuid;

pub use grpc_server::vertiport_rpc_server::{VertiportRpc, VertiportRpcServer};
pub use grpc_server::{UpdateVertiport, Vertiport, VertiportData, Vertiports};

use postgres_types::ToSql;
use std::collections::HashMap;
use tonic::{Code, Request, Response, Status};

///Implementation of gRPC endpoints
#[derive(Debug, Default, Copy, Clone)]
pub struct VertiportImpl {}

#[tonic::async_trait]
impl VertiportRpc for VertiportImpl {
    /// Takes an UUID string (vertiport_id) to get the matching database record.
    ///
    /// # Arguments
    /// * self - The VertiportRpc struct
    /// * request - Request<Id> GRPC request
    ///
    /// # Returns
    /// * Result Vertiport object or Status `not_found` if there was no vertiport found for the given Id
    ///
    /// # Example
    /// ```
    /// use svc_storage_client_grpc::client::vertiport_rpc_client::VertiportRpcClient;
    /// use svc_storage_client_grpc::client::Id;
    ///
    /// let mut vertiport_client = VertiportRpcClient::connect(grpc_endpoint.clone()).await.unwrap();
    /// let result = match vertiport_client.vertiport_by_id(tonic::Request::new(Id {
    ///     id: "54acfe06-dd9b-42e8-8cb4-12a2fb2fa693"
    /// }))
    /// .await
    /// {
    ///    Ok(vertiport) => vertiport.into_inner(),
    ///    Err(e) => panic!("Something went wrong retrieving the vertiport: {}", e),
    /// };
    /// ```
    async fn vertiport_by_id(&self, request: Request<Id>) -> Result<Response<Vertiport>, Status> {
        let id = request.into_inner().id;
        if let Some(vertiport) = VERTIPORTS.lock().await.get(&id) {
            memdb_info!("Found entry for Vertiport. uuid: {}", id);
            Ok(Response::new(vertiport.clone()))
        } else {
            let pool = get_psql_pool();
            let data = VertiportPsql::new(&pool, Uuid::try_parse(&id).unwrap()).await;
            match data {
                Ok(vertiport) => Ok(Response::new(Vertiport {
                    id,
                    data: Some(vertiport.into()),
                })),
                Err(_) => Err(Status::not_found("Not found")),
            }
        }
    }

    /// Takes a `SearchFilter` object to search the database with the provided values.
    ///
    /// This method supports paged results. When the `search_field` and `search_value` are empty, no filters will be applied.
    ///
    /// # Arguments
    /// * self  - The VertiportRpc struct
    /// * request - Request<SearchFilter> GRPC request
    ///
    /// # Returns
    /// * Result Vertiports object or Status `Code::Internal` if there was an error in the search query
    ///
    /// # Example
    /// ```
    /// use svc_storage_client_grpc::client::vertiport_rpc_client::VertiportRpcClient;
    /// use svc_storage_client_grpc::client::SearchFilter;
    ///
    /// let mut vertiport_client = VertiportRpcClient::connect(grpc_endpoint.clone()).await.unwrap();
    /// let result = match vertiport_client.vertiports(tonic::Request::new(SearchFilter {
    ///     search_field: "auth_method",
    ///     search_value: "1",
    ///     page_number: 1,
    ///     results_per_page: 20
    /// }))
    /// .await
    /// {
    ///    Ok(vertiports) => vertiport.into_inner(),
    ///    Err(e) => panic!("Something went wrong creating retrieving vertiports: {}", e),
    /// };
    /// ```
    async fn vertiports(
        &self,
        request: Request<SearchFilter>,
    ) -> Result<Response<Vertiports>, Status> {
        let filter = request.into_inner();
        let mut filter_hash = HashMap::<String, String>::new();
        filter_hash.insert("column".to_string(), filter.search_field);
        filter_hash.insert("value".to_string(), filter.search_value);

        let pool = get_psql_pool();
        match super::psql::search(&pool, &filter_hash).await {
            Ok(vertiports) => Ok(Response::new(vertiports.into())),
            Err(e) => Err(Status::new(Code::Internal, e.to_string())),
        }
    }

    /// Takes an `VertiportData` object to create a new vertiport with the provided data.
    ///
    /// A new UUID will be generated by the database and returned as `id` as part of the returned `Vertiport` object.
    ///
    /// # Arguments
    /// * self - The VertiportRpc struct
    /// * request - Request<VertiportData> GRPC request
    ///
    /// # Returns
    /// Result Vertiport object or Status `Code::Internal` if the vertiport could not be inserted
    ///
    /// # Example
    /// ```
    /// use svc_storage_client_grpc::client::vertiport_rpc_client::{VertiportRpcClient, VertiportData};
    /// const CAL_WORKDAYS_8AM_6PM: &str = "\
    /// DTSTART:20221020T180000Z;DURATION:PT14H
    /// RRULE:FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR
    /// DTSTART:20221022T000000Z;DURATION:PT24H
    /// RRULE:FREQ=WEEKLY;BYDAY=SA,SU";
    ///
    /// let mut vertiport_client = VertiportRpcClient::connect(grpc_endpoint.clone()).await.unwrap();
    /// let result = match vertiport_client.insert_vertiport(tonic::Request::new(VertiportData {
    ///     description: format!("First vertiport built in San Francisco"),
    ///     latitude: 37.7749,
    ///     longitude: -122.4194,
    ///     schedule: Some(CAL_WORKDAYS_8AM_6PM.to_string()),
    /// }))
    /// .await
    /// {
    ///    Ok(vertiport) => vertiport.into_inner(),
    ///    Err(e) => panic!("Something went wrong creating the vertiport: {}", e),
    /// };
    /// ```
    async fn insert_vertiport(
        &self,
        request: Request<VertiportData>,
    ) -> Result<Response<Vertiport>, Status> {
        let mut vertiports = VERTIPORTS.lock().await;
        let data = request.into_inner();
        let pool = get_psql_pool();

        let mut vertiport_data = HashMap::<&str, &(dyn ToSql + Sync)>::new();
        vertiport_data.insert("description", &data.description);
        vertiport_data.insert("longitude", &data.longitude);
        vertiport_data.insert("latitude", &data.latitude);

        match super::psql::create(&pool, vertiport_data.clone()).await {
            Ok(vertiport) => {
                let id = vertiport.id.to_string();
                let vertiport = Vertiport {
                    id: id.clone(),
                    data: Some(data.clone()),
                };
                vertiports.insert(id, vertiport.clone());
                Ok(Response::new(vertiport))
            }
            Err(e) => Err(Status::new(Code::Internal, e.to_string())),
        }
    }

    /// Takes an `UpdateVertiport` object to store new data to the database
    ///
    /// A field mask can be provided to restrict updates to specific fields.
    /// Returns the updated `Vertiport` on success.
    ///
    /// # Arguments
    /// * self  - The VertiportRpc struct
    /// * request - Request<UpdateVertiport> GRPC request
    ///
    /// # Returns
    /// * Result Vertiport object or:
    ///   - Status `not_found` if there was no vertiport found for the given Id
    ///   - Status `cancelled` if no data was provided in the UpdateVertiport object
    ///   - Status `Code::Internal` if the vertiport could not be updated
    ///
    /// # Example
    /// ```
    /// use svc_storage_client_grpc::client::vertiport_rpc_client::{VertiportRpcClient, UpdateVertiport};
    ///
    /// let mut vertiport_client = VertiportRpcClient::connect(grpc_endpoint.clone()).await.unwrap();
    /// let updated_vertiport = match vertiport_client.update_vertiport(tonic::Request::new(UpdateVertiport {
    ///     id: "54acfe06-dd9b-42e8-8cb4-12a2fb2fa693"
    ///     data: Some(VertiportData {
    ///         description: format!("San Francisco's first"),
    ///         latitude: 37.7749,
    ///         longitude: -122.4194,
    ///         schedule: Some(CAL_WORKDAYS_8AM_6PM.to_string()),
    ///     }),
    ///     mask: Some(FieldMask {
    ///         paths: vec!["description".to_string()]
    ///     })
    /// }))
    /// .await
    /// {
    ///    Ok(vertiport) => vertiport.into_inner(),
    ///    Err(e) => panic!("Something went wrong updating the vertiport info: {}", e),
    /// };
    /// ```
    async fn update_vertiport(
        &self,
        request: Request<UpdateVertiport>,
    ) -> Result<Response<Vertiport>, Status> {
        let vertiport_req = request.into_inner();
        let id = match Uuid::try_parse(&vertiport_req.id) {
            Ok(id) => id,
            Err(_e) => Uuid::new_v4(),
        };

        let data = match vertiport_req.data {
            Some(data) => data,
            None => {
                grpc_error!("No data provided for update vertiport with id: {}", id);
                return Err(Status::cancelled("No data found for update vertiport"));
            }
        };

        let pool = get_psql_pool();
        let vertiport = match VertiportPsql::new(&pool, id).await {
            Ok(vertiport) => vertiport,
            Err(e) => {
                grpc_error!("Could not find vertiport with id: {}. {}", id, e);
                return Err(Status::not_found("Unknown vertiport id"));
            }
        };

        let mut vertiport_data = HashMap::<&str, &(dyn ToSql + Sync)>::new();
        vertiport_data.insert("description", &data.description);
        vertiport_data.insert("longitude", &data.longitude);
        vertiport_data.insert("latitude", &data.latitude);

        match vertiport.update(vertiport_data.clone()).await {
            Ok(vertiport_data) => {
                let result = Vertiport {
                    id: id.to_string(),
                    data: Some(vertiport_data.into()),
                };
                // Update cache
                let mut vertiports = VERTIPORTS.lock().await;
                vertiports.insert(id.to_string(), result.clone());

                Ok(Response::new(result.clone()))
            }
            Err(e) => Err(Status::new(Code::Internal, e.to_string())),
        }
    }

    /// Takes an UUID string (vertiport_id) to set the matching vertiport record a deleted in the database.
    ///
    /// The `deleted_at` column will be set to the current timestamp, indicating that the Vertiport is not active anymore.
    ///
    /// # Arguments
    /// * self  - The VertiportRpc struct
    /// * request - Request<Id> GRPC request
    ///
    /// # Returns
    /// * Result empty or Status `Code::Internal` if the vertiport could not be deleted
    ///
    /// # Example
    /// ```
    /// use svc_storage_client_grpc::client::vertiport_rpc_client::VertiportRpcClient;
    /// use svc_storage_client_grpc::client::Id;
    ///
    /// let mut vertiport_client = VertiportRpcClient::connect(grpc_endpoint.clone()).await.unwrap();
    /// let result = match vertiport_client.delete_vertiport(tonic::Request::new(Id {
    ///     id: "54acfe06-dd9b-42e8-8cb4-12a2fb2fa693"
    /// }))
    /// .await
    /// {
    ///    Ok(vertiport) => vertiport.into_inner(),
    ///    Err(e) => panic!("Something went wrong deleting the vertiport: {}", e),
    /// };
    /// ```
    async fn delete_vertiport(&self, request: Request<Id>) -> Result<Response<()>, Status> {
        let id = request.into_inner().id;
        let pool = get_psql_pool();
        let vertiport = VertiportPsql::new(&pool, Uuid::try_parse(&id).unwrap()).await?;

        match vertiport.delete().await {
            Ok(_) => {
                // Update cache
                let mut vertiports = VERTIPORTS.lock().await;
                vertiports.remove(&id);
                Ok(Response::new(()))
            }
            Err(e) => Err(Status::new(Code::Internal, e.to_string())),
        }
    }
}
