syntax = "proto3";
package grpc.flight_plan;

import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "svc-storage-grpc.proto";

// Flight Plan gRPC service
service RpcService {
    // Search flight_plans using a simple filter
    // This function will be deprecated soon, please use `search` instead
    rpc get_all_with_filter(grpc.SearchFilter) returns (List);

    // Returns a [`tonic::Response`] containing an flight_plan [`Object`](super::Object)
    // Takes an [`id`](super::super::Id) to find the right record to return.
    //
    // # Errors
    //
    // Returns [`tonic::Status`] with [`Code::NotFound`](tonic::Code::NotFound) if no record is returned from the database
    //
    // # Examples
    // ```
    // use svc_storage_client_grpc::client::Id;
    // use svc_storage_client_grpc::FlightPlanClient;
    //
    // async fn example () -> Result<(), Box<dyn std::error::Error>> {
    //     let mut flight_plan_client = FlightPlanClient::connect("http://localhost:50051").await?;
    //
    //     let id = "53acfe06-dd9b-42e8-8cb4-12a2fb2fa693".to_owned();
    //     match flight_plan_client
    //         .get_by_id(tonic::Request::new(Id { id }))
    //         .await
    //     {
    //         Ok(res) => {
    //           println!("RESPONSE Flight Plan By ID={:?}", res);
    //           Ok(())
    //         },
    //         Err(e) => Err(Box::new(e))
    //     }
    // }
    // ```
    rpc get_by_id(grpc.Id) returns (Object);

    // Returns a [`tonic::Response`] containing a flight_plan [`Response`](super::Response) object
    // of the inserted record after saving the provided flight_plan [`Data`](super::Data)
    //
    // The given data will be validated before insert.
    // A new UUID will be generated by the database and returned as `id` as part of the returned flight_plan [`Response`](super::Response).
    // Any errors found during validation will be added to the [`ValidationResult`](super::super::ValidationResult).
    //
    // # Errors
    //
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if the [`tonic::Request`] doesn't contain any data.
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if any error is returned from a db call.
    //
    // # Examples
    // ```
    // use svc_storage_client_grpc::client::Id;
    // use svc_storage_client_grpc::FlightPlanClient;
    // use svc_storage_client_grpc::flight_plan::{FlightStatus, FlightPriority, Data};
    // use std::time::SystemTime;
    //
    // async fn example () -> Result<(), Box<dyn std::error::Error>> {
    //     let mut flight_plan_client = FlightPlanClient::connect("http://localhost:50051").await?;
    //
    //     let vehicle_id = "62fb5d13-2cfe-45e2-b89a-16205d15e811".to_owned();
    //     let pilot_id = "a2093c5e-9bbe-4f0f-97ee-276b43fa3759".to_owned();
    //     let departure_vertipad_id = "53acfe06-dd9b-42e8-8cb4-12a2fb2fa693".to_owned();
    //     let destination_vertipad_id = "db67da52-2280-4316-8b29-9cf1bff65931".to_owned();
    //     println!("Starting insert flight plan");
    //     match flight_plan_client
    //     .insert(tonic::Request::new(Data {
    //         flight_status: FlightStatus::Draft as i32,
    //         vehicle_id,
    //         pilot_id,
    //         cargo_weight_grams: vec![20],
    //         flight_distance_meters: 6000,
    //         weather_conditions: Some("Cloudy, low wind".to_owned()),
    //         departure_vertipad_id,
    //         departure_vertiport_id: None,
    //         destination_vertipad_id,
    //         destination_vertiport_id: None,
    //         scheduled_departure: Some(prost_types::Timestamp::from(SystemTime::now())),
    //         scheduled_arrival: Some(prost_types::Timestamp::from(SystemTime::now())),
    //         actual_departure: None,
    //         actual_arrival: None,
    //         flight_release_approval: None,
    //         flight_plan_submitted: Some(prost_types::Timestamp::from(SystemTime::now())),
    //         approved_by: None,
    //         flight_priority: FlightPriority::Low as i32,
    //     }))
    //     .await
    //     {
    //         Ok(res) => {
    //           println!("RESPONSE Flight Plan Insert={:?}", res);
    //           Ok(())
    //         },
    //         Err(e) => Err(Box::new(e))
    //     }
    // }
    // ```
    rpc insert(Data) returns (Response);

    // Returns a [`tonic::Response`] containing a flight_plan [`Response`](super::Response) object
    // of the updated record after saving the provided flight_plan [`Data`](super::Data)
    //
    // The given data will be validated before insert.
    // Any errors found during validation will be added to the [`ValidationResult`](super::super::ValidationResult).
    // A field [`prost_types::FieldMask`] can be provided to restrict updates to specific fields.
    //
    // # Errors
    //
    // Returns [`Status`](tonic::Status) with [`Code::Cancelled`](tonic::Code::Cancelled) if the [`Request`](tonic::Request) doesn't contain any data.
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if any error is returned from a db call.
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if the provided Id can not be converted to a [`uuid::Uuid`].
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if the resulting Vec<tokio_postgres::Row> data could not be converted into [`List`](super::List).
    //
    // # Examples
    // ```
    // use svc_storage_client_grpc::client::{ Id };
    // use svc_storage_client_grpc::FieldMask;
    // use svc_storage_client_grpc::FlightPlanClient;
    // use svc_storage_client_grpc::flight_plan::{FlightStatus, UpdateObject, Data};
    //
    // async fn example () -> Result<(), Box<dyn std::error::Error>> {
    //     let mut flight_plan_client = FlightPlanClient::connect("http://localhost:50051").await?;
    //
    //     let id = "53acfe06-dd9b-42e8-8cb4-12a2fb2fa693".to_owned();
    //     let response = match flight_plan_client
    //         .get_by_id(tonic::Request::new(Id { id: id.clone() }))
    //         .await
    //     {
    //         Ok(res) => {
    //           println!("RESPONSE Flight Plan By ID={:?}", res);
    //           res
    //         },
    //         Err(e) => {
    //             return Err(Box::new(e));
    //         }
    //     };
    //
    //     let flight_plan = response.into_inner().data.unwrap();
    //     match flight_plan_client.update(tonic::Request::new(UpdateObject {
    //         id,
    //         data: Some(Data {
    //             flight_status: FlightStatus::InFlight as i32,
    //             ..flight_plan
    //         }),
    //         mask: Some(FieldMask {
    //             paths: vec!["data.flight_status".to_owned()],
    //         }),
    //     })).await
    //     {
    //         Ok(res) => {
    //           println!("RESPONSE Flight Plan Update={:?}", res);
    //           Ok(())
    //         },
    //         Err(e) => Err(Box::new(e))
    //     }
    // }
    // ```
    rpc update(UpdateObject) returns (Response);

    // Takes an [`Id`](super::super::Id) to set the matching flight_plan record as deleted in the database"
    //
    // # Errors
    //
    // Returns [`Status`](tonic::Status) with [`Code::NotFound`](tonic::Code::NotFound) if no record is returned from the database.
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if any error is returned from a db call.
    //
    // # Examples
    // ```
    // use svc_storage_client_grpc::client::Id;
    // use svc_storage_client_grpc::FlightPlanClient;
    //
    // async fn example () -> Result<(), Box<dyn std::error::Error>> {
    //     let mut flight_plan_client = FlightPlanClient::connect("http://localhost:50051").await?;
    //
    //     let id = "53acfe06-dd9b-42e8-8cb4-12a2fb2fa693".to_owned();
    //     match flight_plan_client.delete(tonic::Request::new(Id{id})).await
    //     {
    //         Ok(res) => {
    //           println!("RESPONSE Flight Plan Delete={:?}", res);
    //           Ok(())
    //         },
    //         Err(e) => Err(Box::new(e))
    //     }
    // }
    // ```
    rpc delete(grpc.Id) returns (google.protobuf.Empty);

    // Search flight_plans using an advanced filter
    //
    // This method supports paged results.
    //
    // # Errors
    //
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if any error is returned from the db search result.
    // Returns [`Status`](tonic::Status) with [`Code::Internal`](tonic::Code::Internal) if the resulting Vec<tokio_postgres::Row> data could not be converted into [`List`](super::List).
    //
    // # Examples
    // ```
    // use svc_storage_client_grpc::FlightPlanClient;
    // use svc_storage_client_grpc::client::AdvancedSearchFilter;
    //
    // async fn example () -> Result<(), Box<dyn std::error::Error>> {
    //     let mut flight_plan_client = FlightPlanClient::connect("http://localhost:50051").await?;
    //
    //     let pilot_id = "a2093c5e-9bbe-4f0f-97ee-276b43fa3759".to_owned();
    //     let filter = AdvancedSearchFilter::search_equals("pilot_id".to_owned(), pilot_id)
    //         .and_is_not_null("scheduled_departure".to_owned());
    //
    //     match flight_plan_client
    //         .search(tonic::Request::new(filter))
    //         .await
    //     {
    //         Ok(res) => {
    //           println!("RESPONSE Flight Plan Search={:?}", res);
    //           Ok(())
    //         },
    //         Err(e) => Err(Box::new(e))
    //     }
    // }
    // ```
    rpc search(grpc.AdvancedSearchFilter) returns (List);
}

// Flight Status Enum
enum FlightStatus {
    // READY
    READY = 0;
    // BOARDING
    BOARDING = 1;
    // IN_FLIGHT
    IN_FLIGHT = 3;
    // FINISHED
    FINISHED = 4;
    // CANCELLED
    CANCELLED = 5;
    // DRAFT
    DRAFT = 6;
}
// Flight Priority Enum
enum FlightPriority {
    // LOW
    LOW = 0;
    // HIGH
    HIGH = 1;
    // EMERGENCY
    EMERGENCY = 2;
}

// Response struct returning an [Object] on success and [ValidationResult] if invalid fields were provided
message Response {
    // struct with field -> error pairs to provide feedback about invalid fields
    grpc.ValidationResult validation_result = 1;
    // Object struct with id [String] in [Uuid](uuid::Uuid) format and [Data] struct with flight_plan data
    optional Object object = 2;
}

// Object struct with `id` and `data` field
// * `id` [String] in [Uuid](uuid::Uuid) format
// * `data` [Data] struct with flight_plan data
message Object {
    //id UUID v4
    string id = 1;
    //data
    Data data = 2;
}

// UpdateObject struct with `id`, `data` and `mask` fields
// * `id` [String] in [Uuid](uuid::Uuid) format
// * `data` [Data] struct with flight_plan data which should be used for update
// * `mask` [FieldMask] struct with flight_plan fields that should be updated
message UpdateObject {
    // `id` [String] in [Uuid](uuid::Uuid) format
    string id = 1;
    // struct with flight_plan data which should be used for update
    Data data = 2;
    // struct with flight_plan fields that should be updated
    google.protobuf.FieldMask mask = 3;
}

// Data struct with flight_plan data
message Data {
    // pilot_id UUID v4
    string pilot_id = 1;
    // vehicle_id UUID v4
    string vehicle_id = 2;
    // cargo weight in grams per package
    repeated int64 cargo_weight_grams = 3;
    // flight_distance in meters
    int64 flight_distance_meters = 4;
    // weather_conditions
    optional string weather_conditions = 5;
    // departure_vertiport_id UUID v4, only listed for get results, not needed for creation (known through pad_id)
    optional string departure_vertiport_id = 6;
    // departure_vertipad_id UUID v4
    string departure_vertipad_id = 7;
    // destination_vertiport_id UUID v4, only listed for get results, not needed for creation (known through pad_id)
    optional string destination_vertiport_id = 8;
    // destination_vertipad_id UUID v4
    string destination_vertipad_id = 9;
    // scheduled_departure
    google.protobuf.Timestamp scheduled_departure = 10;
    // scheduled_arrival
    google.protobuf.Timestamp scheduled_arrival = 11;
    // actual_departure
    optional google.protobuf.Timestamp actual_departure = 12;
    // actual_arrival
    optional google.protobuf.Timestamp actual_arrival = 13;
    // flight_release_approval date and time
    optional google.protobuf.Timestamp flight_release_approval = 14;
    // flight_plan_submitted date and time
    optional google.protobuf.Timestamp flight_plan_submitted = 15;
    // approved_by UUID v4
    optional string approved_by = 16;
    // flight_status
    FlightStatus flight_status = 17;
    // flightPriority
    FlightPriority flight_priority = 18;
}

// Struct containing a `list` of flight_plan [Vec\<Object\>]
message List {
    // array/vector of flight items
    repeated Object list = 1;
}
